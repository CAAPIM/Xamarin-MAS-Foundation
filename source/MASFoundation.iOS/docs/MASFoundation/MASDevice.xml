<Type Name="MASDevice" FullName="MASFoundation.MASDevice">
  <TypeSignature Language="C#" Value="public class MASDevice : MASFoundation.MASObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MASDevice extends MASFoundation.MASObject" />
  <AssemblyInfo>
    <AssemblyName>MASFoundation.iOS</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MASFoundation.MASObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("MASDevice", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
    The `MASDevice` class is a local representation of device data.
    </summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MASDevice ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor, initializes a new instance of this class.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MASDevice (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
            This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization). This is part of the Foundation.NSCoding protocol.

            If you want to create a subclass of this object and continue to support deserialization from an archive, you should implement a constructor with an identical signature: taking a single parameter of type Foundation.NSCoder and decorate it with the [Export("initWithCoder:"] attribute declaration.

            The state of this object can also be serialized by using the companion method, EncodeTo.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MASDevice (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
            This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place. Once the allocation has taken place, the constructor has to initialize the object. With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MASDevice (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the Objective-C class.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects; Called by the runtime.</summary>
        <remarks>
            This constructor is invoked by the runtime infrastructure (ObjCRuntime.GetNSObject (IntPtr)) to create a new managed representation for a pointer to an unmanaged Objective-C object. You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAttribute">
      <MemberSignature Language="C#" Value="public virtual void AddAttribute (Foundation.NSObject name, Foundation.NSObject value, MASFoundation.MASObjectResponseErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddAttribute(class Foundation.NSObject name, class Foundation.NSObject value, class MASFoundation.MASObjectResponseErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addAttribute:value:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="Foundation.NSObject" />
        <Parameter Name="value" Type="Foundation.NSObject" />
        <Parameter Name="completion" Type="MASFoundation.MASObjectResponseErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASObjectResponseErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">Key of the attribute to be associated with the device.</param>
        <param name="value">Value of the attribute to be associated with the device.</param>
        <param name="completion">The MASCompletionErrorBlock block that receives the results.</param>
        <summary>Create or update a new attribute for the current device, return an error when exceed ${mag-device-max-metadata} configuration in the server.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Foundation.NSObject&gt; AddAttributeAsync (Foundation.NSObject name, Foundation.NSObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Foundation.NSObject&gt; AddAttributeAsync(class Foundation.NSObject name, class Foundation.NSObject value) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Foundation.NSObject&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="Foundation.NSObject" />
        <Parameter Name="value" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="name">Key of the attribute to be associated with the device.</param>
        <param name="value">Value of the attribute to be associated with the device.</param>
        <summary>Create or update a new attribute for the current device, return an error when exceed ${mag-device-max-metadata} configuration in the server.</summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>
            Each Xamarin class mirrors an unmanaged Objective-C class. This value contains the pointer to the Objective-C class.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDevice">
      <MemberSignature Language="C#" Value="public static MASFoundation.MASDevice CurrentDevice ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MASFoundation.MASDevice CurrentDevice() cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("currentDevice")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MASFoundation.MASDevice</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        The device the application is running on. This is a singleton object.
        </summary>
        <returns>A singleton 'MASDevice' object.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeregisterAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; DeregisterAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; DeregisterAsync() cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        Deregister the application resources on this device. This is a two step operation.
        
        <para>It will first attempt to remove the device's registered record in the cloud.  If it fails,
        an error is returned and the appropriate notification is sent and it will stop there.</para><para>Upon success of the first operation, deregistration in the cloud, it will then attempt to
        wipe the device of all credential settings.  If it fails, an error is returned and the appropriate
        notification is sent.It will stop here.</para><para>*  WARNING #1: </para><para>    A call to deregistration in the same session as the device was initially registered will
            fail and may leave the device in a strange state.This call should work post
            initial registration and a restart of the application.</para><para>* WARNING #2: </para><para>    A successful call to deregistration will leave the current application session
            without required credentials and settings.  You must restart the application
            to re-register the application and retrieve new credentials.</para><para>This should be considered an advanced feature.If you make this available to end users it
        should not be made too easily accessible and the UI control should be marked and possibly labeled
        to accentuate that it will wipe settings both in the cloud and locally on the device. We
        recommend you also provide an additional user confirmation UI component to make it clear to 
        the user what will occur and allow them to cancel the operation or proceed.</para><para>Although an asynchronous block callback parameter is provided for detecting the response,
        optionally you can set that to null and the caller can observe the lifecycle notifications instead.</para></summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeregisterWithCompletion">
      <MemberSignature Language="C#" Value="public virtual void DeregisterWithCompletion (MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeregisterWithCompletion(class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("deregisterWithCompletion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="completion">Completion.</param>
        <summary>
        Deregister the application resources on this device. This is a two step operation.
        
        <para>It will first attempt to remove the device's registered record in the cloud.  If it fails,
        an error is returned and the appropriate notification is sent and it will stop there.</para><para>Upon success of the first operation, deregistration in the cloud, it will then attempt to
        wipe the device of all credential settings.  If it fails, an error is returned and the appropriate
        notification is sent.It will stop here.</para><para>*  WARNING #1: </para><para>    A call to deregistration in the same session as the device was initially registered will
            fail and may leave the device in a strange state.This call should work post
            initial registration and a restart of the application.</para><para>* WARNING #2: </para><para>    A successful call to deregistration will leave the current application session
            without required credentials and settings.  You must restart the application
            to re-register the application and retrieve new credentials.</para><para>This should be considered an advanced feature.If you make this available to end users it
        should not be made too easily accessible and the UI control should be marked and possibly labeled
        to accentuate that it will wipe settings both in the cloud and locally on the device. We
        recommend you also provide an additional user confirmation UI component to make it clear to 
        the user what will occur and allow them to cancel the operation or proceed.</para><para>Although an asynchronous block callback parameter is provided for detecting the response,
        optionally you can set that to null and the caller can observe the lifecycle notifications instead.</para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public virtual void GetAttribute (Foundation.NSObject name, MASFoundation.MASObjectResponseErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAttribute(class Foundation.NSObject name, class MASFoundation.MASObjectResponseErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("getAttribute:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="Foundation.NSObject" />
        <Parameter Name="completion" Type="MASFoundation.MASObjectResponseErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASObjectResponseErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">Key of the attribute to be retrieved for the current device.</param>
        <param name="completion">A standard MASObjectResponseErrorBlock block that will receive the response object which needs to perform type casting based on the object type, and NSError object when error occurs.</param>
        <summary>Get attribute by name, return empty NSDictionary if no attribute is found</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Foundation.NSObject&gt; GetAttributeAsync (Foundation.NSObject name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Foundation.NSObject&gt; GetAttributeAsync(class Foundation.NSObject name) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Foundation.NSObject&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="name">Key of the attribute to be retrieved for the current device.</param>
        <summary>Get attribute by name, return empty NSDictionary if no attribute is found</summary>
        <returns><![CDATA[Tuple<NSObject, NSError>, object that contains the response object which needs to perform type casting based on the object type, and NSError object when error occurs.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public virtual void GetAttributes (MASFoundation.MASObjectResponseErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAttributes(class MASFoundation.MASObjectResponseErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("getAttributes:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="completion" Type="MASFoundation.MASObjectResponseErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASObjectResponseErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="completion">A standard MASObjectResponseErrorBlock block that will receive the response object which needs to perform type casting based on the object type, and NSError object when error occurs.</param>
        <summary>Get all attributes for the current device, return empty NSDictionary if no attributes found.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Foundation.NSObject&gt; GetAttributesAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Foundation.NSObject&gt; GetAttributesAsync() cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Foundation.NSObject&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Get all attributes for the current device, return empty NSDictionary if no attributes found.</summary>
        <returns><![CDATA[Tuple<NSObject, NSError>, object that contains the response object which needs to perform type casting based on the object type, and NSError object when error occurs.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Identifier">
      <MemberSignature Language="C#" Value="public virtual string Identifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Identifier" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("identifier")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        The MASDevice identifier.
        </summary>
        <value>The device identifier.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBeingAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsBeingAuthorized { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBeingAuthorized" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isBeingAuthorized")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setIsBeingAuthorized:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets or sets a value indicating whether this <see cref="T:MASFoundation.MASDevice" /> is being authorized with other devices through proximity login.
        </summary>
        <value>
          <c>true</c> if is being authorized; otherwise, <c>false</c>.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRegistered">
      <MemberSignature Language="C#" Value="public virtual bool IsRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRegistered" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isRegistered")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets a value indicating whether this <see cref="T:MASFoundation.MASDevice" /> is registered.
        </summary>
        <value>
          <c>true</c> if is registered; otherwise, <c>false</c>.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("name")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the MASDevice name.
        </summary>
        <value>The MASDevice name.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllAttributes">
      <MemberSignature Language="C#" Value="public virtual void RemoveAllAttributes (MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAllAttributes(class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeAllAttributes:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="completion">The MASCompletionErrorBlock block that receives the results.</param>
        <summary>Remove all attributes for the current device.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllAttributesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; RemoveAllAttributesAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; RemoveAllAttributesAsync() cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove all attributes for the current device.</summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAttribute">
      <MemberSignature Language="C#" Value="public virtual void RemoveAttribute (Foundation.NSObject name, MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAttribute(class Foundation.NSObject name, class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeAttribute:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="Foundation.NSObject" />
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">Key of the attribute to be removed for the current device.</param>
        <param name="completion">The MASCompletionErrorBlock block that receives the results.</param>
        <summary>Remove attribute by name, fails if the device attribute does not exist.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAttributeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; RemoveAttributeAsync (Foundation.NSObject name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; RemoveAttributeAsync(class Foundation.NSObject name) cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="name">Key of the attribute to be removed for the current device.</param>
        <summary>Remove attribute by name, fails if the device attribute does not exist.</summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetLocally">
      <MemberSignature Language="C#" Value="public virtual void ResetLocally ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetLocally() cil managed" />
      <MemberType>Method</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("resetLocally")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        Reset the application's locally stored data on the device only.  This does NOT call the
        backend service to remove the device record.You must call MASDevice.CurrentDevice().DeregisterWithCompletion() to do that.
        
        <para>WARNING: if you call this method, all access credentials and locally stored configuration related to the application will be removed.
        Re-authentication proccess will be triggered whenever you are trying to access the gateway.</para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public virtual string Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("status")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the MASDevice status.
        </summary>
        <value>The MASDevice status.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
