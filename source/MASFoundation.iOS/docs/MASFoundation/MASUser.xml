<Type Name="MASUser" FullName="MASFoundation.MASUser">
  <TypeSignature Language="C#" Value="public class MASUser : MASFoundation.MASObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MASUser extends MASFoundation.MASObject" />
  <AssemblyInfo>
    <AssemblyName>MASFoundation.iOS</AssemblyName>

  </AssemblyInfo>
  <Base>
    <BaseTypeName>MASFoundation.MASObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("MASUser", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
    The `MASUser` class is a local representation of user data.
    </summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MASUser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor, initializes a new instance of this class.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MASUser (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
            This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization). This is part of the Foundation.NSCoding protocol.

            If you want to create a subclass of this object and continue to support deserialization from an archive, you should implement a constructor with an identical signature: taking a single parameter of type Foundation.NSCoder and decorate it with the [Export("initWithCoder:"] attribute declaration.

            The state of this object can also be serialized by using the companion method, EncodeTo.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MASUser (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
            This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place. Once the allocation has taken place, the constructor has to initialize the object. With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MASUser (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the Objective-C class.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects; Called by the runtime.</summary>
        <remarks>
            This constructor is invoked by the runtime infrastructure (ObjCRuntime.GetNSObject (IntPtr)) to create a new managed representation for a pointer to an unmanaged Objective-C object. You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessToken">
      <MemberSignature Language="C#" Value="public virtual string AccessToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessToken" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessToken")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the access token of the user, if authenticated.
        </summary>
        <value>The access token.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="public virtual bool Active { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberType>Property</MemberType>
      
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("active")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>User active status.</summary>
        <value>
          <c>true</c> if is actived; otherwise, <c>false</c>.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Addresses">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSDictionary&lt;Foundation.NSString,Foundation.NSString&gt; Addresses { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSDictionary`2&lt;class Foundation.NSString, class Foundation.NSString&gt; Addresses" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("addresses", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSDictionary&lt;Foundation.NSString,Foundation.NSString&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the addresses.
        </summary>
        <value>The addresses.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthCredentialsType">
      <MemberSignature Language="C#" Value="public static string AuthCredentialsType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string AuthCredentialsType" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("authCredentialsType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Previously, or currently used authCredentialsType for the session.
        <para>If the SDK is not properly initialized, null will be returned regardless of the authentication status of the SDK.</para><para>If the SDK was never authenticated before, SDK will also return null as a result.</para></summary>
        <value>NSString of previously, or currently used authCredentialsType as in String.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>

      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>
            Each Xamarin class mirrors an unmanaged Objective-C class. This value contains the pointer to the Objective-C class.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static MASFoundation.MASUser CurrentUser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MASFoundation.MASUser CurrentUser" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("currentUser")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MASFoundation.MASUser</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        GeThe authenticated user for the application, if any. null returned if none. This is a singleton object.
        </summary>
        <value>A singleton 'MASUser' object.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmailAddresses">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSDictionary&lt;Foundation.NSString,Foundation.NSString&gt; EmailAddresses { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSDictionary`2&lt;class Foundation.NSString, class Foundation.NSString&gt; EmailAddresses" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("emailAddresses", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSDictionary&lt;Foundation.NSString,Foundation.NSString&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the email addresses.
        </summary>
        <value>The email addresses.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FamilyName">
      <MemberSignature Language="C#" Value="public virtual string FamilyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FamilyName" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("familyName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the string value of family name.
        </summary>
        <value>The string value of family name.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FormattedName">
      <MemberSignature Language="C#" Value="public virtual string FormattedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormattedName" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("formattedName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the string value of formatted name.
        </summary>
        <value>The string value of formatted name.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GivenName">
      <MemberSignature Language="C#" Value="public virtual string GivenName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string GivenName" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("givenName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the string value of given name.
        </summary>
        <value>The string value of given name.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public virtual string[] Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Groups" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("groups", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the groups.
        </summary>
        <value>The groups.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isAuthenticated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets a value indicating whether this <see cref="T:MASFoundation.MASUser" /> is authenticated.
        </summary>
        <value>
          <c>true</c> if is authenticated; otherwise, <c>false</c>.
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCurrentUser">
      <MemberSignature Language="C#" Value="public virtual bool IsCurrentUser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentUser" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isCurrentUser")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets a value indicating whether this <see cref="T:MASFoundation.MASUser" /> is current user.
        </summary>
        <value>
          <c>true</c> if is current user; otherwise, <c>false</c>.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSessionLocked">
      <MemberSignature Language="C#" Value="public virtual bool IsSessionLocked { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSessionLocked" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isSessionLocked")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets a value indicating whether this <see cref="T:MASFoundation.MASUser" />'s session is locked.
        </summary>
        <value>
          <c>true</c> if is session locked; otherwise, <c>false</c>.
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LockSessionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; LockSessionAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; LockSessionAsync() cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Lock currently authenticated user session with device's local authentication (Device's Passcode or Biometric Authentication).
            <para>
            This will lock current user session and block most of operations except for MASUser.CurrentUser.LogoutWithCompletion();
            and MASDevice.CurrentDevice().DeregisterWithCompletion().
            Alternatively, locked user session can be removed by MASUser.CurrentUser.RemoveSessionLock()
            which will remove credentials from protected storage of the device with local authentication.
            </para><para>
            After locking user session, MASUser.CurrentUser will still exists;
            however, MASUser.CurrentUser.IsAuthenticated property will reflect the lock status and will return false until it's unlocked.
            Session lock status can also be checked through MASUser.CurrentUser.isSessionLocked property.
            </para></summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LockSessionWithCompletion">
      <MemberSignature Language="C#" Value="public virtual void LockSessionWithCompletion (MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LockSessionWithCompletion(class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("lockSessionWithCompletion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="completion">The MASCompletionErrorBlock block that receives the results.</param>
        <summary>
            Lock currently authenticated user session with device's local authentication (Device's Passcode or Biometric Authentication).
            <para>
            This will lock current user session and block most of operations except for MASUser.CurrentUser.LogoutWithCompletion();
            and MASDevice.CurrentDevice().DeregisterWithCompletion().
            Alternatively, locked user session can be removed by MASUser.CurrentUser.RemoveSessionLock()
            which will remove credentials from protected storage of the device with local authentication.
            </para><para>
            After locking user session, MASUser.CurrentUser will still exists;
            however, MASUser.CurrentUser.IsAuthenticated property will reflect the lock status and will return false until it's unlocked.
            Session lock status can also be checked through MASUser.CurrentUser.isSessionLocked property.
            </para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginWithAuthCredentials">
      <MemberSignature Language="C#" Value="public static void LoginWithAuthCredentials (MASFoundation.MASAuthCredentials authCredentials, MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoginWithAuthCredentials(class MASFoundation.MASAuthCredentials authCredentials, class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("loginWithAuthCredentials:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="authCredentials" Type="MASFoundation.MASAuthCredentials" />
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="authCredentials">MASAuthCredentials object that contains credentials.</param>
        <param name="completion">The MASCompletionErrorBlock block that receives the results.  On a successful completion, the user available via MASUser.CurrentUser has been updated with the new information.</param>
        <summary>
            Authenticate a user via asynchronous request with MASAuthCredentials object.
            <para>
            This will accept any objects that inherits from MASAuthCredentials and all MASAuthCredentials objects that adheres device registration/user authentication logics
            on backend services.
            </para><para>
            This will create an MASUser.CurrentUser upon a successful result.
            </para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginWithAuthCredentialsAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; LoginWithAuthCredentialsAsync (MASFoundation.MASAuthCredentials authCredentials);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; LoginWithAuthCredentialsAsync(class MASFoundation.MASAuthCredentials authCredentials) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="authCredentials" Type="MASFoundation.MASAuthCredentials" />
      </Parameters>
      <Docs>
        <param name="authCredentials">MASAuthCredentials object that contains credentials.</param>
        <summary>
            Authenticate a user via asynchronous request with MASAuthCredentials object.
            <para>
            This will accept any objects that inherits from MASAuthCredentials and all MASAuthCredentials objects that adheres device registration/user authentication logics
            on backend services.
            </para><para>
            This will create an MASUser.CurrentUser upon a successful result.
            </para></summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginWithAuthorizationCode">
      <MemberSignature Language="C#" Value="public static void LoginWithAuthorizationCode (string authorizationCode, MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoginWithAuthorizationCode(string authorizationCode, class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("loginWithAuthorizationCode:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="authorizationCode" Type="System.String" />
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="authorizationCode">The authorization code for the user.</param>
        <param name="completion">The MASCompletionErrorBlock block that receives the results.  On a successful completion, the user available via MASUser.CurrentUser has been updated with the new information.</param>
        <summary>
            Authenticate a user via asynchronous request with authorization code.
            <para>
            This will create an MASUser.CurrentUser upon a successful result.
            </para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginWithAuthorizationCodeAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; LoginWithAuthorizationCodeAsync (string authorizationCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; LoginWithAuthorizationCodeAsync(string authorizationCode) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="authorizationCode" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="authorizationCode">The authorization code for the user.</param>
        <summary>
            Authenticate a user via asynchronous request with authorization code.
            <para>
            This will create an MASUser.CurrentUser upon a successful result.
            </para></summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginWithIdToken">
      <MemberSignature Language="C#" Value="public static void LoginWithIdToken (string idToken, string tokenType, MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoginWithIdToken(string idToken, string tokenType, class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("loginWithIdToken:tokenType:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="idToken" Type="System.String" />
        <Parameter Name="tokenType" Type="System.String" />
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="idToken">The id_token for the user.</param>
        <param name="tokenType">Token type of id_token.</param>
        <param name="completion">The MASCompletionErrorBlock block that receives the results.  On a successful completion, the user available via MASUser.CurrentUser has been updated with the new information.</param>
        <summary>
            Authenticate a user via asynchronous request with id_token.
            <para>
            This will create an MASUser.CurrentUser upon a successful result.
            </para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginWithIdTokenAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; LoginWithIdTokenAsync (string idToken, string tokenType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; LoginWithIdTokenAsync(string idToken, string tokenType) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="idToken" Type="System.String" />
        <Parameter Name="tokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="idToken">The id_token for the user.</param>
        <param name="tokenType">Token type of id_token.</param>
        <summary>
            Authenticate a user via asynchronous request with id_token.
            <para>
            This will create an MASUser.CurrentUser upon a successful result.
            </para></summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginWithUserName">
      <MemberSignature Language="C#" Value="public static void LoginWithUserName (string userName, string password, MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoginWithUserName(string userName, string password, class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("loginWithUserName:password:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="userName">The userName of the user.</param>
        <param name="password">The password of the user.</param>
        <param name="completion">The MASCompletionErrorBlock block that receives the results.  On a successful completion, the user available via MASUser.CurrentUser has been updated with the new information.</param>
        <summary>
            Authenticate a user via asynchronous request with basic credentials.
            <para>
            This will create an MASUser.CurrentUser upon a successful result.
            </para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginWithUserNameAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; LoginWithUserNameAsync (string userName, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; LoginWithUserNameAsync(string userName, string password) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userName">The userName of the user.</param>
        <param name="password">The password of the user.</param>
        <summary>
            Authenticate a user via asynchronous request with basic credentials.
            <para>
            This will create an MASUser.CurrentUser upon a successful result.
            </para></summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogoutAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; LogoutAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; LogoutAsync() cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Logout an already authenticated user via asynchronous request.
            <para>This will return <c>true</c> upon a successful result.</para></summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogoutWithCompletion">
      <MemberSignature Language="C#" Value="public virtual void LogoutWithCompletion (MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LogoutWithCompletion(class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("logoutWithCompletion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="completion">The MASCompletionErrorBlock block that receives the results.  On a successful completion, the user
        available via[MASUser currentUser] has been updated with the new information.</param>
        <summary>
        Logout an already authenticated user via asynchronous request.
        <para>This will return <c>true</c> upon a successful result.</para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhoneNumbers">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSDictionary&lt;Foundation.NSString,Foundation.NSString&gt; PhoneNumbers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSDictionary`2&lt;class Foundation.NSString, class Foundation.NSString&gt; PhoneNumbers" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("phoneNumbers", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSDictionary&lt;Foundation.NSString,Foundation.NSString&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the phone numbers.
        </summary>
        <value>The phone numbers.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Photos">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSDictionary&lt;Foundation.NSString,Foundation.NSObject&gt; Photos { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSDictionary`2&lt;class Foundation.NSString, class Foundation.NSObject&gt; Photos" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("photos", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSDictionary&lt;Foundation.NSString,Foundation.NSObject&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the photos.
        </summary>
        <value>The photos.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSessionLock">
      <MemberSignature Language="C#" Value="public virtual void RemoveSessionLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveSessionLock() cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeSessionLock")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Remove user session that had been protected device's local authentication.
            <para>
            This interface can be used when end-user chooses to not provide local authentication and clean up the session.
            </para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUserInfoAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;MASFoundation.MASUser&gt; RequestUserInfoAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class MASFoundation.MASUser&gt; RequestUserInfoAsync() cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;MASFoundation.MASUser&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        Requesting userInfo for the MASUser object.
        <para>This method will retrieve additional information on the MASUser object.</para></summary>
        <returns>Returns MASUSer object with updated value which is also available through the current MASUser object that is making this request.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUserInfoWithCompletion">
      <MemberSignature Language="C#" Value="public virtual void RequestUserInfoWithCompletion (MASFoundation.MASUserResponseErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RequestUserInfoWithCompletion(class MASFoundation.MASUserResponseErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("requestUserInfoWithCompletion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="completion" Type="MASFoundation.MASUserResponseErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASUserResponseErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="completion">The MASUserResponseErrorBlock block that returns MASUSer object with updated value which is also available through the current MASUser object that is making this request, and NSError object in case any error is encountered during the process.</param>
        <summary>
        Requesting userInfo for the MASUser object.
        This method will retrieve additional information on the MASUser object.
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockSessionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; UnlockSessionAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; UnlockSessionAsync() cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        Unlock currently locked user session with device's local authentication (Device's Passcode or Biometric Authentication).
        <para>
        This will unlock current user session and unblock all of the operations through SDK.
        </para><para>
        After unlocking user session, MASUser.CurrentUser will reflect correct authentication and lock status.
        </para></summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockSessionWithCompletion">
      <MemberSignature Language="C#" Value="public virtual void UnlockSessionWithCompletion (MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnlockSessionWithCompletion(class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("unlockSessionWithCompletion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="completion">MASCompletionErrorBlock block that receives the results.</param>
        <summary>
        Unlock currently locked user session with device's local authentication (Device's Passcode or Biometric Authentication).
        <para>
        This will unlock current user session and unblock all of the operations through SDK.
        </para><para>
        After unlocking user session, MASUser.CurrentUser will reflect correct authentication and lock status.
        </para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockSessionWithUserOperationPromptMessage">
      <MemberSignature Language="C#" Value="public virtual void UnlockSessionWithUserOperationPromptMessage (string userOperationPrompt, MASFoundation.MASCompletionErrorBlock completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnlockSessionWithUserOperationPromptMessage(string userOperationPrompt, class MASFoundation.MASCompletionErrorBlock completion) cil managed" />
      <MemberType>Method</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("unlockSessionWithUserOperationPromptMessage:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userOperationPrompt" Type="System.String" />
        <Parameter Name="completion" Type="MASFoundation.MASCompletionErrorBlock">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMASCompletionErrorBlock))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="userOperationPrompt">NSString message that will be displayed on system local authentication dialog.</param>
        <param name="completion">MASCompletionErrorBlock block that receives the results.</param>
        <summary>
        Unlock currently locked user session with device's local authentication (Device's Passcode or Biometric Authentication) and specified message on system local authentication dialog.
        <para>
        This will unlock current user session and unblock all of the operations through SDK.
        </para><para>
        After unlocking user session, MASUser.CurrentUser will reflect correct authentication and lock status.
        </para></summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockSessionWithUserOperationPromptMessageAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Tuple&lt;bool,Foundation.NSError&gt;&gt; UnlockSessionWithUserOperationPromptMessageAsync (string userOperationPrompt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Tuple`2&lt;bool, class Foundation.NSError&gt;&gt; UnlockSessionWithUserOperationPromptMessageAsync(string userOperationPrompt) cil managed" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Tuple&lt;System.Boolean,Foundation.NSError&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userOperationPrompt" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userOperationPrompt">NSString message that will be displayed on system local authentication dialog.</param>
        <summary>
        Unlock currently locked user session with device's local authentication (Device's Passcode or Biometric Authentication) and specified message on system local authentication dialog.
        <para>
        This will unlock current user session and unblock all of the operations through SDK.
        </para><para>
        After unlocking user session, MASUser.CurrentUser will reflect correct authentication and lock status.
        </para></summary>
        <returns><![CDATA[Tuple<bool, NSError>, the first item indicates if the operation was completed successfully, the second item may contain an NSError object in case any error is encountered.]]></returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public virtual string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserName" />
      <MemberType>Property</MemberType>

      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("userName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        Gets the string value of the username.
        </summary>
        <value>The string value of the username.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
